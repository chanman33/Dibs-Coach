'use server'

import { createAuthClient } from '@/utils/auth'
import { withServerAction } from '@/utils/middleware/withServerAction'
import { SYSTEM_ROLES } from '@/utils/roles/roles'
import { PROFILE_STATUS, ProfileStatus, type RealEstateDomain, REAL_ESTATE_DOMAINS } from '@/utils/types/coach'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// Validation schema for inputs
const UpdateProfileStatusSchema = z.object({
  coachUlid: z.string().min(1, 'Coach ID is required'),
  status: z.enum([
    PROFILE_STATUS.DRAFT,
    PROFILE_STATUS.PUBLISHED,
    PROFILE_STATUS.ARCHIVED,
    PROFILE_STATUS.SUSPENDED
  ])
})

// Type for coach profile data in admin UI
interface CoachProfileData {
  userUlid: string
  profileUlid: string
  firstName: string
  lastName: string
  email: string
  profileImageUrl: string | null
  profileStatus: ProfileStatus
  completionPercentage: number
  realEstateDomains: string[]
  hourlyRate: number | null
  createdAt: string
  updatedAt: string
}

// Update coach profile status from admin
export const updateCoachProfileStatus = withServerAction<{ success: boolean }, z.infer<typeof UpdateProfileStatusSchema>>(
  async (data, { userUlid, systemRole }) => {
    try {
      if (systemRole !== SYSTEM_ROLES.SYSTEM_OWNER && systemRole !== SYSTEM_ROLES.SYSTEM_MODERATOR) {
        return {
          data: null,
          error: {
            code: 'FORBIDDEN',
            message: 'Only system owners and moderators can update coach profile status'
          }
        }
      }

      const { coachUlid, status } = UpdateProfileStatusSchema.parse(data)
      const supabase = await createAuthClient()

      // If trying to publish, check if profile is complete
      if (status === PROFILE_STATUS.PUBLISHED) {
        const { data: profile } = await supabase
          .from('CoachProfile')
          .select('completionPercentage')
          .eq('userUlid', coachUlid)
          .single()

        if (!profile || profile.completionPercentage < 100) {
          return {
            data: null,
            error: {
              code: 'VALIDATION_ERROR',
              message: 'Profile must be complete before publishing'
            }
          }
        }
      }
      
      // Update the coach profile status
      const { error: updateError } = await supabase
        .from('CoachProfile')
        .update({
          profileStatus: status as 'DRAFT' | 'PUBLISHED' | 'ARCHIVED',
          updatedAt: new Date().toISOString()
        })
        .eq('userUlid', coachUlid)
      
      if (updateError) {
        console.error('[ADMIN_UPDATE_COACH_STATUS_ERROR]', updateError)
        return {
          data: null,
          error: {
            code: 'DATABASE_ERROR',
            message: 'Error updating coach profile status',
            details: { error: updateError }
          }
        }
      }
      
      // Log the status change for audit
      await supabase
        .from('AdminAuditLog')
        .insert({
          ulid: '', // Will be generated by DB
          adminUlid: userUlid,
          action: 'UPDATE_COACH_PROFILE_STATUS',
          targetType: 'CoachProfile',
          targetUlid: coachUlid,
          details: { 
            status: status,
            timestamp: new Date().toISOString()
          },
          createdAt: new Date().toISOString()
        })
      
      // Revalidate relevant paths
      revalidatePath('/dashboard/system/coach-mgmt')
      
      return {
        data: { success: true },
        error: null
      }
    } catch (error) {
      console.error('[ADMIN_UPDATE_COACH_STATUS_ERROR]', error)
      return {
        data: null,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred',
          details: error instanceof Error ? { message: error.message } : undefined
        }
      }
    }
  }
)

// Fetch all coach profiles for admin
export const fetchCoachProfiles = withServerAction<CoachProfileData[]>(
  async (_, { systemRole }) => {
    try {
      if (systemRole !== SYSTEM_ROLES.SYSTEM_OWNER && systemRole !== SYSTEM_ROLES.SYSTEM_MODERATOR) {
        return {
          data: null,
          error: {
            code: 'FORBIDDEN',
            message: 'Only system owners and moderators can view all coach profiles'
          }
        }
      }

      const supabase = await createAuthClient()
      
      const { data, error } = await supabase
        .from('User')
        .select(`
          ulid,
          firstName,
          lastName,
          email,
          profileImageUrl,
          realEstateDomains,
          CoachProfile (
            ulid,
            coachSkills,
            hourlyRate,
            completionPercentage,
            profileStatus,
            createdAt,
            updatedAt
          )
        `)
        .eq('isCoach', true)
        .order('createdAt', { ascending: false })
      
      if (error) {
        console.error('[FETCH_COACH_PROFILES_ERROR]', error)
        return {
          data: null,
          error: {
            code: 'DATABASE_ERROR',
            message: 'Failed to fetch coach profiles',
            details: { error }
          }
        }
      }
      
      const coachProfiles = data.map(user => {
        const profile = Array.isArray(user.CoachProfile) ? user.CoachProfile[0] : user.CoachProfile
        
        return {
          userUlid: user.ulid,
          profileUlid: profile?.ulid || '',
          firstName: user.firstName || '',
          lastName: user.lastName || '',
          email: user.email || '',
          profileImageUrl: user.profileImageUrl,
          profileStatus: profile?.profileStatus || PROFILE_STATUS.DRAFT,
          completionPercentage: profile?.completionPercentage || 0,
          realEstateDomains: user.realEstateDomains || [],
          hourlyRate: profile?.hourlyRate || null,
          createdAt: profile?.createdAt || '',
          updatedAt: profile?.updatedAt || ''
        }
      })
      
      return {
        data: coachProfiles,
        error: null
      }
    } catch (error) {
      console.error('[FETCH_COACH_PROFILES_ERROR]', error)
      return {
        data: null,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred',
          details: error instanceof Error ? { message: error.message } : undefined
        }
      }
    }
  }
)

// Fetch a single coach profile for admin
export const fetchCoachProfile = withServerAction<CoachProfileData, string>(
  async (coachUlid, { systemRole }) => {
    try {
      if (systemRole !== SYSTEM_ROLES.SYSTEM_OWNER && systemRole !== SYSTEM_ROLES.SYSTEM_MODERATOR) {
        return {
          data: null,
          error: {
            code: 'FORBIDDEN',
            message: 'Only system owners and moderators can view coach profiles'
          }
        }
      }

      const supabase = await createAuthClient()
      
      const { data, error } = await supabase
        .from('User')
        .select(`
          ulid,
          firstName,
          lastName,
          email,
          profileImageUrl,
          realEstateDomains,
          CoachProfile (
            ulid,
            coachSkills,
            hourlyRate,
            completionPercentage,
            profileStatus,
            createdAt,
            updatedAt
          )
        `)
        .eq('ulid', coachUlid)
        .single()
      
      if (error) {
        console.error('[FETCH_COACH_PROFILE_ERROR]', error)
        return {
          data: null,
          error: {
            code: 'DATABASE_ERROR',
            message: 'Failed to fetch coach profile',
            details: { error }
          }
        }
      }
      
      const profile = Array.isArray(data.CoachProfile) ? data.CoachProfile[0] : data.CoachProfile
      
      const coachProfile = {
        userUlid: data.ulid,
        profileUlid: profile?.ulid || '',
        firstName: data.firstName || '',
        lastName: data.lastName || '',
        email: data.email || '',
        profileImageUrl: data.profileImageUrl,
        profileStatus: profile?.profileStatus || PROFILE_STATUS.DRAFT,
        completionPercentage: profile?.completionPercentage || 0,
        realEstateDomains: data.realEstateDomains || [],
        hourlyRate: profile?.hourlyRate || null,
        createdAt: profile?.createdAt || '',
        updatedAt: profile?.updatedAt || ''
      }
      
      return {
        data: coachProfile,
        error: null
      }
    } catch (error) {
      console.error('[FETCH_COACH_PROFILE_ERROR]', error)
      return {
        data: null,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred',
          details: error instanceof Error ? { message: error.message } : undefined
        }
      }
    }
  }
)

export async function refreshCoachManagement() {
  'use server'
  revalidatePath('/dashboard/system/coach-mgmt')
  return { success: true }
}

/**
 * Updates a coach's real estate domains
 * This replaces the previous updateCoachSpecialties function which had issues with type casting
 */
export async function updateRealEstateDomains({
  coachUlid,
  domains
}: {
  coachUlid: string
  domains: string[]
}) {
  'use server'
  
  try {
    const supabase = await createAuthClient()
    
    // Validate that all domains are valid RealEstateDomain values
    const validDomains = domains.filter(domain => 
      Object.values(REAL_ESTATE_DOMAINS).includes(domain as RealEstateDomain)
    ) as RealEstateDomain[]
    
    // First fetch the existing user data to ensure we're not losing any information
    const { data: existingUser, error: fetchError } = await supabase
      .from('User')
      .select('*')
      .eq('ulid', coachUlid)
      .single()
    
    if (fetchError) {
      console.error('[FETCH_USER_ERROR]', fetchError)
      return { 
        data: null, 
        error: { 
          message: 'Failed to fetch user data',
          details: fetchError.message
        } 
      }
    }
    
    // Now perform the update with only the fields we want to change
    const { data, error } = await supabase
      .from('User')
      .update({ 
        realEstateDomains: validDomains,
        updatedAt: new Date().toISOString()
      })
      .eq('ulid', coachUlid)
      .select()
      .single()

    if (error) {
      console.error('[UPDATE_DOMAINS_ERROR]', error)
      return { 
        data: null, 
        error: { 
          message: 'Failed to update domains',
          details: error.message
        } 
      }
    }

    revalidatePath('/dashboard/system/coach-mgmt')
    return { data, error: null }
  } catch (error) {
    console.error('[UPDATE_DOMAINS_ERROR]', error)
    return { 
      data: null, 
      error: { 
        message: 'Failed to update domains',
        details: error instanceof Error ? error.message : String(error)
      } 
    }
  }
} 