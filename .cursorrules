# Project Implementation Rules
version: 1.0

# Core Configuration
core:
  directories:
    lib: "Core API configurations & base implementations"
    app/api: "API routes & endpoints"
    utils: "Helpers, types, & server actions"
    components: "UI components & client-side logic"
  
  env_vars:
    server_side: "direct process.env access"
    client_side: "NEXT_PUBLIC_ prefix required"
    validation: "type-safe with runtime checks"
  
  security:
    forbidden: ["Exposed API keys", "Unvalidated inputs", "Missing CORS headers"]
    required: ["Rate limiting", "Security event logging", "Input sanitization", "Authentication checks"]


# Authentication Implementation
auth:
  architecture:
    current_patterns:
      directory_structure:
        - "utils/auth/": "Core auth utilities and context"
        - "utils/roles/": "Role and capability management"
        - "utils/hooks/": "Auth-related hooks"
        - "components/auth/": "Auth UI components"
        - "app/api/auth/": "Auth-related API routes"
      
      forbidden_patterns:
        - "Direct clerk imports outside server components"
        - "Standalone auth.ts files"
        - "Direct role checks without utility functions"
        - "Multiple auth hook implementations"
        - "Duplicate provider implementations"
        - "Client-side role storage"
        - "Direct database queries for roles"
    
    file_structure:
      auth_core:
        - location: "utils/auth/auth-context.ts"
          purpose: "Single source of truth for auth state"
          exports: ["getAuthContext", "AuthContext type"]
        - location: "utils/auth/auth-middleware.ts"
          purpose: "Route and API protection"
          exports: ["createAuthMiddleware"]
        - location: "utils/auth/auth-client.ts"
          purpose: "Supabase client creation"
          exports: ["createAuthClient"]
        - location: "utils/auth/auth-utils.ts"
          purpose: "Core auth verification"
          exports: ["verifyAuth", "handleAuthError"]
      
      roles:
        - location: "utils/roles/roles.ts"
          purpose: "Role and capability definitions"
          exports: ["SYSTEM_ROLES", "USER_CAPABILITIES", "types"]
        - location: "utils/roles/checkUserRole.ts"
          purpose: "Server-side role verification"
          exports: ["getUserRoleContext", "hasPermission"]
      
      hooks:
        - location: "utils/hooks/useAuth.ts"
          purpose: "Client-side auth state"
          exports: ["useAuth"]
          forbidden: "No alternative implementations"
          return_type: |
            {
              isLoading: boolean
              isSignedIn: boolean | null
              userId: string | null
              userUlid: string | null
              systemRole: SystemRole
              capabilities: UserCapability[]
            }
      
      components:
        - location: "components/auth/with-auth.tsx"
          purpose: "Component protection"
          exports: ["WithAuth"]
          replaces: ["with-role.tsx", "other auth wrappers"]
        - location: "components/auth/providers.tsx"
          purpose: "Auth context provider"
          exports: ["AuthProviders", "useAuthContext"]
        - location: "components/auth/not-authorized.tsx"
          purpose: "Error UI component"
          exports: ["NotAuthorized"]
      
      api:
        - location: "app/api/auth/after-signup/"
          purpose: "User creation flow"
        - location: "app/api/auth/recover/"
          purpose: "Account recovery"
        - location: "app/api/auth/webhook/"
          purpose: "Clerk webhook handling"
    
    usage_guidelines:
      server_side:
        - "Always use getUserRoleContext for role checks"
        - "Use createAuthClient for database access"
        - "Handle errors with proper logging"
        - "Verify auth before any protected operation"
        - "Use verifyAuth for route protection"
      
      client_side:
        - "Use WithAuth for component protection"
        - "Use useAuth for state access"
        - "Never create alternative implementations"
        - "No direct role checks in components"
        - "Handle loading and error states"
      
      data_flow:
        - "Clerk -> auth-context -> roles -> capabilities"
        - "Single source of truth for auth state"
        - "Consistent error handling patterns"
        - "Type-safe throughout the flow"
      
      error_handling:
        format: |
          console.error('[AUTH_ERROR]', {
            code: error.code,
            message: error.message,
            context: { userId, path, timestamp }
          })
        
        types:
          - "UnauthorizedError: Not signed in"
          - "ForbiddenError: Insufficient permissions"
          - "ValidationError: Invalid data"
          - "DatabaseError: Role fetch failed"

    core_files:
      auth_context:
        location: "utils/auth/auth-context.ts"
        purpose: "Single source of truth for auth state"
        features:
          - "Cached auth context using React cache"
          - "Single database query for all auth data"
          - "Type-safe context structure"
        exports:
          - "getAuthContext(): Promise<AuthContext>"
          - "useAuthContext(): AuthContext hook"
      
      auth_middleware:
        location: "utils/auth/auth-middleware.ts"
        purpose: "Unified auth protection layer"
        features:
          - "Route protection"
          - "Role validation"
          - "Capability checks"
          - "Organization validation"
        exports:
          - "createAuthMiddleware(options): Middleware"
          - "withAuth(component, options): HOC"
      
      auth_types:
        location: "utils/types/auth.ts"
        purpose: "Centralized auth type definitions"
        types:
          - |
            interface AuthContext {
              userId: string          // Clerk ID
              userUlid: string       // Database ID
              systemRole: SystemRole
              capabilities: UserCapability[]
              orgRole?: OrgRole
              orgLevel?: OrgLevel
              subscription?: {
                status: string
                planId: string
              }
            }
          - "type AuthOptions"
          - "type AuthError"
    
    protection_layers:
      middleware:
        location: "middleware.ts"
        features:
          - "Route-based protection"
          - "Auth context injection"
          - "Early auth validation"
        implementation: |
          export default createAuthMiddleware({
            publicRoutes: ['/api/webhooks(.*)', '/auth(.*)'],
            protectedRoutes: ['/dashboard(.*)'],
            roleRoutes: {
              admin: ['/admin(.*)'],
              coach: ['/coach(.*)']
            }
          })

      api_routes:
        location: "utils/api/with-api-auth.ts"
        features:
          - "API route protection"
          - "Role validation"
          - "Error handling"
        implementation: |
          export const withApiAuth = createAuthMiddleware({
            validateRequest: true,
            handleErrors: true
          })

      server_actions:
        location: "utils/actions/with-server-auth.ts"
        features:
          - "Server action protection"
          - "Context injection"
          - "Error handling"
        implementation: |
          export const withServerAuth = createAuthMiddleware({
            validateAction: true,
            injectContext: true
          })

  data_flow:
    auth_context:
      caching:
        - "Use React cache for performance"
        - "Revalidate on role/capability changes"
        - "Clear on sign out"
      
      query_optimization:
        - "Single database query for all auth data"
        - "Join related tables efficiently"
        - "Include only necessary fields"
      
      error_handling:
        - "Typed error responses"
        - "Consistent error format"
        - "Proper error logging"

  best_practices:
    general:
      - "Single source of truth for auth state"
      - "Cached auth context"
      - "Type-safe throughout"
      - "Clear error handling"
    
    performance:
      - "Minimize database queries"
      - "Use efficient joins"
      - "Cache auth context"
      - "Early validation in middleware"
    
    security:
      - "Validate auth before operations"
      - "Type-safe role checks"
      - "Proper error handling"
      - "Secure context passing"

  implementation_steps:
    setup:
      - "Create auth context structure"
      - "Implement middleware protection"
      - "Set up type definitions"
      - "Configure error handling"
    
    migration:
      - "Update existing components"
      - "Migrate to new context"
      - "Update protection layers"
      - "Test thoroughly"

  error_handling:
    types:
      - "UnauthorizedError"
      - "ForbiddenError"
      - "ValidationError"
    
    logging:
      format: |
        console.error('[AUTH_ERROR]', {
          code: error.code,
          message: error.message,
          context: {
            userId,
            path,
            timestamp
          }
        })
    
    responses:
      format: |
        {
          error: {
            code: string
            message: string
            details?: Record<string, any>
          }
        }

  validation:
    context:
      - "Validate all auth context fields"
      - "Type-safe role checking"
      - "Capability validation"
    
    requests:
      - "Validate auth headers"
      - "Check required roles"
      - "Verify capabilities"

  metrics:
    tracking:
      - "Auth operation duration"
      - "Cache hit rates"
      - "Error rates"
      - "Role distribution"
    
    logging:
      - "Auth failures"
      - "Performance metrics"
      - "Security events" 

database:
  # General Rules
  supabase:
    required: true
    usage: "All data operations must use Supabase client"
    client_init:
      import: "import { createServerClient } from '@supabase/ssr'"
      cookies: "await cookies() from next/headers"
      config:
        url: "process.env.SUPABASE_URL"
        key: "process.env.SUPABASE_SERVICE_KEY"
      implementation: "Use createAuthClient from utils/auth.ts"
  
  prisma:
    allowed_for: "schema management and migrations only"
    forbidden: "direct database operations"
    seeding:
      location: "prisma/seed.js"
      format: "CommonJS format with require() statements"
      dependencies: ["@supabase/supabase-js", "dotenv"]
      required_fields: ["updatedAt", "JSON.stringify for arrays/objects"]
      error_handling: "console.error('Seed error:', error)"
  
  # Naming & Structure
  conventions:
    tables:
      format: "PascalCase"
      examples:
        - "User not users"
        - "CoachApplication not coach_applications"
        - "RealtorProfile not realtor_profile"
        - "CalendlyIntegration"
      rules:
        - "Must match exact case in queries"
        - "Singular form, not plural"
        - "Compound names should be clear and descriptive"
    
    columns:
      primary_key: 
        format: "id"
        type: "BIGINT NOT NULL"
      foreign_keys:
        format: "camelCase with DbId suffix"
        type: "BIGINT NOT NULL"
        examples:
          - "userDbId"
          - "coachDbId"
          - "menteeDbId"
        rules:
          - "Must reference database id, not Clerk id"
          - "Must include DbId suffix for clarity"
          - "Must use BIGINT type"
      auth_identifier:
        format: "userId"
        type: "TEXT NOT NULL"
        usage: "Only for Clerk auth ID storage"
        location: "Only in User table"
      regular_columns:
        format: "camelCase"
        examples:
          - "firstName"
          - "lastName"
          - "profileImageUrl"
      timestamps:
        required:
          - "createdAt: TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
          - "updatedAt: TIMESTAMP WITH TIME ZONE"
        format: "camelCase"
        operations: "Must include updatedAt: new Date().toISOString() in all insert/update operations"
    
    queries:
      supabase:
        table_reference: '.from("User") // Exact PascalCase required'
        column_reference: '.eq("userId", value) // Exact camelCase required'
        examples:
          correct:
            - '.from("User").select()'
            - '.from("RealtorProfile").eq("userDbId", id)'
          incorrect:
            - '.from("user").select()'
            - '.from("realtor_profile").eq("user_id", id)'
  
  # ID Management
  id_conventions:
    auth:
      clerk_id: "userId: TEXT (e.g., user_2r0JFaVbINR4TBRNFzcwIsyEXV0)"
      location: "Only stored in User table"
    database:
      internal_id: "ulid: String @id @db.Char(26)"
      foreign_key: "entityUlid: String @db.Char(26) (references Entity.ulid)"
      generation: 
        location: "Client-side only"
        utility: "utils/ulid.ts"
        rules:
          - "Never use database-level ULID generation"
          - "Always generate ULIDs before database operations"
          - "Use provided ULID utility functions for all generations"
    usage:
      - "Use userId (string) when querying by Clerk ID in User table only"
      - "Use ulid for all database relationships"
      - "Never use Clerk IDs in foreign key relationships"
      - "Generate all ULIDs client-side before database operations"
  
  # Relationships
  relationships:
    naming:
      primary_keys: "ulid String @id @db.Char(26)"
      foreign_keys: "entityUlid String @db.Char(26) REFERENCES Entity(ulid)"
    constraints:
      - "All foreign keys must reference ULID fields"
      - "All foreign keys should have appropriate indexes"
      - "Use descriptive names for relationship fields"
      - "Add map parameter for duplicate constraint names"
    multiple_relations:
      - "When a table has multiple relationships to the same table, specify the exact relationship in joins"
      - "Example: User!CoachApplication_userUlid_fkey for applicant, User!CoachApplication_reviewedBy_fkey for reviewer"
  
  # Required Fields & Indexes
  required_fields:
    id:
      format: "String @id @db.Char(26)"
      generation: "Client-side ULID generation required before insert"
      foreign_key: "String @db.Char(26)"
    timestamps:
      format: "TIMESTAMP WITH TIME ZONE"
      fields:
        - "createdAt DEFAULT NOW()"
        - "updatedAt"
      operations: "Must include updatedAt in all insert/update operations"
    indexes:
      - "Add @@index([foreignKeyUlid]) for all foreign keys"
      - "Add @unique where appropriate for one-to-one relationships"
      - "ULID fields automatically indexed by create_ulid_indexes() function"
  
  # Best Practices
  best_practices:
    auth:
      - "Use ensureUserExists for user management"
      - "Convert Clerk ID to ULID early in API routes"
      - "Use ULIDs for all internal operations"
      - "Keep auth logic separate from database logic"
    naming:
      - "Use descriptive suffixes: Ulid for foreign keys"
      - "Be explicit about ID types in field names"
      - "Use consistent naming across related tables"
    types:
      - "Use String @db.Char(26) for all ULIDs"
      - "Use TEXT for Clerk userId and other string identifiers"
      - "Use TIMESTAMP WITH TIME ZONE for all timestamps"
    error_handling:
      - "Use consistent error logging format"
      - "Include context in error messages"
      - "Handle edge cases appropriately"
      - "Proper error responses in API routes"
    ulid:
      - "Always generate ULIDs using provided utility functions"
      - "Generate ULIDs immediately before database operations"
      - "Never rely on database-level ULID generation"
      - "Include error handling for ULID generation failures"
      - "Log ULID generation and usage in debug contexts"
  
  # Migrations
  migrations:
    rules:
      - "Always include both up and down migrations"
      - "Test migrations on development before production"
      - "Back up data before running migrations"
      - "Use descriptive migration names"

# Server-Side Implementation
server:
  components:
    directives: ["'use server'", "authentication check", "try-catch blocks", "error logging"]
  
  actions:
    location: "utils/actions"
    structure:
      - "'use server' directive required"
      - "Separate file per resource type"
      - "Named exports for each action"
      - "User ID resolution before operations"
    naming:
      prefix: ["fetch", "create", "update", "delete"]
      format: "prefixResourceName (e.g., fetchUsers, createPost)"
  
  api:
    required_steps:
      - "Authentication check"
      - "Database user ID lookup"
      - "Data validation"
      - "Database operation"
      - "Error handling"
      - "Response formatting"
    response_format:
      success: "NextResponse.json({ data })"
      error: "new NextResponse('message', { status: code })"

# Type System
types:
  organization:
    base_location: "utils/types"
    structure:
      - "Domain-specific files in utils/types/"
      - "Root types.ts only re-exports and common utilities"
      - "Keep enums and constants in the domain file where they are primarily used"
      - "Export types from a single source of truth"
    naming:
      schemas: "camelCase with Schema suffix (e.g., userSchema)"
      types: "PascalCase (e.g., User, SessionWithRelations)"
      files: "domain name in singular form (e.g., user.ts, session.ts)"
      enums:
        format: "SCREAMING_SNAKE_CASE for values"
        examples:
          - "export const GOAL_STATUS = { IN_PROGRESS: 'IN_PROGRESS' }"
          - "export const GOAL_TYPE = { SALES_VOLUME: 'SALES_VOLUME' }"
        rules:
          - "Enum values should match their keys"
          - "Use 'as const' assertion for type safety"
          - "Export both enum and derived type"
    validation:
      - "Use Zod for all schema definitions"
      - "Remove reference to Prisma native enums"
      - "Export both schemas and inferred types"
      - "Ensure enum values match their types exactly"
      - "For Zod enums, use z.enum() with explicit values array"
      - "Define enum values as uppercase constants"
      - "Validate enum values match database constraints"
      examples:
        - |
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS',
            COMPLETED: 'COMPLETED',
            OVERDUE: 'OVERDUE'
          } as const;
          
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS))
          });
    type_safety:
      - "Avoid duplicate type definitions across files"
      - "Import types from their canonical source"
      - "Use type assertions sparingly and only when necessary"
      - "Ensure enum values and their types are synchronized"
      - "Use 'as const' with enum objects to preserve literal types"
      - "Export both enum object and TypeScript type"
      examples:
        - |
          // Correct enum definition
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS'
          } as const;
          
          export type GoalStatus = typeof GOAL_STATUS[keyof typeof GOAL_STATUS];
          
          // Correct schema usage
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS) as [string, ...string[]])
          });
    required_patterns:
      base_schemas:
        - "createSchema for creation"
        - "updateSchema for updates"
        - "base schema for full model"
      common_fields:
        - "id: z.number() for database IDs"
        - "createdAt/updatedAt as dates"
        - "Proper nullability with .nullable()"
      enums:
        - "Define constants and types in the same file"
        - "Use string literal types that match exactly"
        - "Export both const object and type"
    imports:
      - "Import Supabase types from '@supabase/supabase-js'"
      - "Import Database types from '@/types/supabase'"
      - "Import Zod from zod"
      - "No cross-importing between domain files"
      - "Import types from their original definition file"
      - "Use generated Supabase types for database operations"
      - "Keep custom type definitions aligned with Supabase schema"

    supabase_types:
      - "Use Database type for table definitions"
      - "Use Tables type for table names"
      - "Use Enums type for database enums"
      - "Use generated types for insert/update operations"
      examples:
        - "type DbTables = Database['public']['Tables']"
        - "type User = DbTables['User']['Row']"
        - "type InsertUser = DbTables['User']['Insert']"
        - "type UpdateUser = DbTables['User']['Update']"

# User Roles and Capabilities
roles:
  definition:
    system_roles:
      location: "utils/roles/roles.ts"
      values:
        - "SYSTEM_OWNER: highest level admin access"
        - "SYSTEM_MODERATOR: system-wide moderation"
        - "USER: standard user"
        - "COACH: coach user (deprecated, use capabilities instead)"
        - "MENTEE: mentee user (deprecated, use capabilities instead)"
    
    user_capabilities:
      location: "utils/roles/roles.ts, utils/types/user.ts"
      primary_capabilities:
        - "COACH: can act as a coach"
        - "MENTEE: can act as a mentee"
      domain_capabilities:
        description: "Domain-specific capabilities for coach profiles"
        examples:
          - "REALTOR: real estate agent specialization"
          - "INVESTOR: investment specialization"
          - "MORTGAGE: mortgage specialization"
  
  storage:
    dual_approach:
      explanation: "The system uses both boolean flags and capabilities array for core roles"
      boolean_flags:
        - "isCoach: corresponds to COACH capability"
        - "isMentee: corresponds to MENTEE capability"
      capabilities_array:
        - "String array storing all user capabilities"
        - "Must include both core and domain capabilities"
        - "Boolean flags must be kept in sync with array contents"
      sync_utility:
        location: "utils/permissions.ts"
        function: "updateUserCapabilities()"
        description: "Ensures boolean flags are updated based on array contents"
  
  best_practices:
    capability_checks:
      - "Use hasCapability() from utils/permissions.ts"
      - "Check boolean flags only for quick access path optimization"
      - "Always use utility functions rather than direct database queries"
      - "System-level admins (SYSTEM_OWNER, SYSTEM_MODERATOR) bypass capability checks"
    
    updating_capabilities:
      - "Always use addUserCapability() or removeUserCapability() from utils/permissions.ts"
      - "Never update capabilities array and boolean flags separately"
      - "Include systemRole checks for admin operations"
      - "For batch operations, use updateUserCapabilities() with complete array"
    
    constants:
      - "Use CAPABILITIES constants from utils/permissions.ts"
      - "Avoid string literals for capability names to prevent typos"
      - "Import UserCapability type for type safety"
    
  implementation:
    coach_users:
      - "Check if user is a coach with hasCapability(userId, CAPABILITIES.COACH)"
      - "Add coach capability with addUserCapability(userId, CAPABILITIES.COACH)"
      - "Remove coach capability with removeUserCapability(userId, CAPABILITIES.COACH)"
      - "For domain specialties, use addUserCapability(userId, 'REALTOR')"
    
    admin_users:
      - "Use systemRole for system-wide admin access, not capabilities"
      - "systemRole is single-value, while capabilities is an array"
      - "System admins implicitly have access to all capabilities"
      - "Update systemRole separately from capabilities"

# Error Handling
errors:
  logging:
    format: "console.error('[CONTEXT_ERROR]', error)"
    contexts: ["API", "AUTH", "DB", "PAYMENT", "WEBHOOK", "TYPE", "VALIDATION"]
  return_format: "{ data: T | null, error: Error | null }"
  client_server:
    validation_errors:
      format: |
        {
          code: 'VALIDATION_ERROR',
          message: string,
          details: z.ZodError.flatten()
        }
      handling:
        - "Always return structured error objects from server actions"
        - "Include error code, message, and details"
        - "Preserve ZodError details for form validation"
        - "Log full error on server, sanitized error on client"
      examples: |
        // Server-side
        if (error instanceof z.ZodError) {
          console.error('[VALIDATION_ERROR]', {
            error,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          return {
            data: null,
            error: {
              code: 'VALIDATION_ERROR',
              message: 'Invalid form data',
              details: error.flatten()
            }
          };
        }

        // Client-side
        try {
          const result = await submitForm(data);
          if (result.error) {
            if (result.error.code === 'VALIDATION_ERROR') {
              // Handle validation errors in the form
              setFormErrors(result.error.details);
            } else {
              // Handle other errors
              toast.error(result.error.message);
            }
          }
        } catch (error) {
          console.error('[SUBMIT_FORM_ERROR]', {
            error,
            timestamp: new Date().toISOString()
          });
          toast.error('Failed to submit form');
        }

  server_actions:
    error_handling:
      - "Use withServerAction wrapper for consistent error handling"
      - "Log full error context on server side"
      - "Return structured error responses"
      - "Include error code and message"
      - "Add timestamp to error logs"
      - "Preserve stack traces in development"
    validation:
      - "Validate all inputs with Zod schemas"
      - "Return detailed validation errors"
      - "Log validation failures with context"
      - "Include original and parsed values in logs"
    examples: |
      export const submitForm = withServerAction(
        async (data, { userUlid }) => {
          try {
            const validatedData = schema.parse(data);
            // ... rest of the action
          } catch (error) {
            console.error('[ACTION_ERROR]', {
              error,
              data,
              userUlid,
              stack: error instanceof Error ? error.stack : undefined,
              timestamp: new Date().toISOString()
            });
            return {
              data: null,
              error: {
                code: error instanceof z.ZodError ? 'VALIDATION_ERROR' : 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unexpected error occurred',
                details: error instanceof z.ZodError ? error.flatten() : undefined
              }
            };
          }
        }
      );

# Integrations
integrations:
  stripe:
    rules: ["Secret key server-side only", "Webhook handlers", "Supabase storage", "Error handling"]
  
  calendly:
    structure:
      lib: ["lib/calendly-api.ts", "lib/calendly.ts"]
      features: ["Server-side API calls", "Client widget", "Webhook handling"]
      storage: ["Supabase event storage", "User profile linking"]
  
  zoom:
    structure:
      lib: ["lib/zoom-api.ts", "app/api/zoom/auth/"]
      features: ["Server-side creation", "JWT auth", "Webhook processing"]
      security: ["Server-side credentials", "OAuth flow", "Token validation"]

# Meeting Scheduling
scheduling:
  flow: ["Calendly event", "Zoom meeting", "Database record", "Notification"]
  required_fields:
    event: ["start_time", "end_time", "attendees", "meeting_link"]
    storage: ["event_id", "meeting_id", "user_id", "status"]
  error_handling: ["Double booking", "API failures", "Timezone issues", "Creation failures"]

# Documentation
documentation:
  required_comments: ["Complex types", "Schema relationships", "Validation rules"]
  jsdoc_format: |
    /**
     * @description Type description
     * @property {type} name - Property description
     */ 

# Database Operations
database:
  operations:
    inserts:
      required_steps:
        - "Generate ULID using utility function"
        - "Prepare insert data with generated ULID"
        - "Execute insert operation"
        - "Handle any ULID generation or insert errors"
      example: |
        const newUlid = generateUlid();
        await supabase
          .from("Table")
          .insert({
            ulid: newUlid,
            // other fields
          });
    updates:
      rules:
        - "Never update ULID fields"
        - "Use ULIDs for all where clauses"
        - "Include updatedAt timestamp"
    queries:
      rules:
        - "Use ULIDs for relationship joins"
        - "Index ULID columns for performance"
        - "Use proper ULID comparison functions"

  utilities:
    location: "utils/ulid.ts"
    required_functions:
      - "generateUlid(): Generate new ULID"
      - "isValidUlid(ulid: string): Validate ULID format"
      - "extractTimestamp(ulid: string): Extract creation time"
      - "compareUlids(a: string, b: string): Compare two ULIDs"
    error_handling:
      - "Handle generation failures gracefully"
      - "Validate ULID format before database operations"
      - "Include proper error messages and logging"
    
    usage_examples: |
      // Generate new ULID
      const ulid = generateUlid();
      
      // Insert with ULID
      if (isValidUlid(ulid)) {
        await supabase
          .from("Table")
          .insert({
            ulid,
            // other fields
          });
      }
      
      // Query by ULID
      const { data, error } = await supabase
        .from("Table")
        .select()
        .eq("ulid", targetUlid);

  indexes:
    automatic:
      - "All ULID columns automatically indexed by create_ulid_indexes()"
      - "B-tree indexes for efficient lookups and joins"
    manual:
      - "Add additional indexes for specific query patterns"
      - "Consider composite indexes for common query combinations"
    maintenance:
      - "Monitor index usage and performance"
      - "Reindex when necessary"
      - "Clean up unused indexes"

