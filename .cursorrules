# Project Implementation Rules
version: 1.0

# Core Configuration
core:
  directories:
    lib: "Core API configurations & base implementations"
    app/api: "API routes & endpoints"
    utils: "Helpers, types, & server actions"
    components: "UI components & client-side logic"
  
  env_vars:
    server_side: "direct process.env access"
    client_side: "NEXT_PUBLIC_ prefix required"
    validation: "type-safe with runtime checks"
  
  security:
    forbidden: ["Exposed API keys", "Unvalidated inputs", "Missing CORS headers"]
    required: ["Rate limiting", "Security event logging", "Input sanitization", "Authentication checks"]

# Authentication & Database
auth:
  clerk:
    import: "import { auth } from '@clerk/nextjs/server'"
    rules:
      - "await auth() required"
      - "Server-side auth checks"
      - "Webhook event handling"
      - "Supabase user sync"
      - "Protected routes in middleware"
      - "No @clerk/nextjs without server"

database:
  # General Rules
  supabase:
    required: true
    usage: "All data operations must use Supabase client"
    client_init:
      import: "import { createServerClient } from '@supabase/ssr'"
      cookies: "await cookies() from next/headers"
      config:
        url: "process.env.SUPABASE_URL"
        key: "process.env.SUPABASE_SERVICE_KEY"
  
  prisma:
    allowed_for: "schema management and migrations only"
    forbidden: "direct database operations"
    seeding:
      location: "prisma/seed.js"
      format: "CommonJS format with require() statements"
      dependencies: ["@supabase/supabase-js", "dotenv"]
      required_fields: ["updatedAt", "JSON.stringify for arrays/objects"]
      error_handling: "console.error('Seed error:', error)"
  
  # Naming & Structure
  conventions:
    tables:
      format: "PascalCase"
      examples:
        - "User not users"
        - "CoachApplication not coach_applications"
        - "RealtorProfile not realtor_profile"
        - "CalendlyIntegration"
      rules:
        - "Must match exact case in queries"
        - "Singular form, not plural"
        - "Compound names should be clear and descriptive"
    
    columns:
      primary_key: 
        format: "id"
        type: "BIGINT NOT NULL"
      foreign_keys:
        format: "camelCase with DbId suffix"
        type: "BIGINT NOT NULL"
        examples:
          - "userDbId"
          - "coachDbId"
          - "menteeDbId"
        rules:
          - "Must reference database id, not Clerk id"
          - "Must include DbId suffix for clarity"
          - "Must use BIGINT type"
      auth_identifier:
        format: "userId"
        type: "TEXT NOT NULL"
        usage: "Only for Clerk auth ID storage"
        location: "Only in User table"
      regular_columns:
        format: "camelCase"
        examples:
          - "firstName"
          - "lastName"
          - "profileImageUrl"
      timestamps:
        required:
          - "createdAt: TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
          - "updatedAt: TIMESTAMP WITH TIME ZONE"
        format: "camelCase"
        operations: "Must include updatedAt: new Date().toISOString() in all insert/update operations"
    
    queries:
      supabase:
        table_reference: '.from("User") // Exact PascalCase required'
        column_reference: '.eq("userId", value) // Exact camelCase required'
        examples:
          correct:
            - '.from("User").select()'
            - '.from("RealtorProfile").eq("userDbId", id)'
          incorrect:
            - '.from("user").select()'
            - '.from("realtor_profile").eq("user_id", id)'
  
  # ID Management
  id_conventions:
    auth:
      clerk_id: "userId: TEXT (e.g., user_2r0JFaVbINR4TBRNFzcwIsyEXV0)"
      location: "Only stored in User table"
    database:
      internal_id: "id: BIGINT (auto-incrementing)"
      foreign_key: "userDbId: BIGINT (references User.id)"
    usage:
      - "Use userId (string) when querying by Clerk ID in User table only"
      - "Use id/userDbId (BIGINT) for all database relationships"
      - "Never use Clerk IDs in foreign key relationships"
  
  # Relationships
  relationships:
    naming:
      primary_keys: "id BIGINT PRIMARY KEY"
      foreign_keys: "entityDbId BIGINT REFERENCES tableName(id)"
    constraints:
      - "All foreign keys must reference internal database IDs"
      - "All foreign keys should have appropriate indexes"
      - "Use descriptive names for relationship fields"
      - "Add map parameter for duplicate constraint names"
    multiple_relations:
      - "When a table has multiple relationships to the same table, specify the exact relationship in joins"
      - "Example: User!CoachApplication_userId_fkey for applicant, User!CoachApplication_reviewedBy_fkey for reviewer"
  
  # Required Fields & Indexes
  required_fields:
    timestamps:
      format: "TIMESTAMP WITH TIME ZONE"
      fields:
        - "createdAt DEFAULT NOW()"
        - "updatedAt"
      operations: "Must include updatedAt in all insert/update operations"
    indexes:
      - "Add @@index([foreignKeyField]) for all foreign keys"
      - "Add @unique where appropriate for one-to-one relationships"
  
  # Best Practices
  best_practices:
    auth:
      - "Convert Clerk ID to database ID early in API routes"
      - "Use database IDs for all internal operations"
      - "Keep auth logic separate from database logic"
    naming:
      - "Use descriptive suffixes: DbId, Id, Code"
      - "Be explicit about ID types in field names"
      - "Use consistent naming across related tables"
    types:
      - "Use BIGINT for all IDs and foreign keys"
      - "Use TEXT for Clerk userId and other string identifiers"
      - "Use TIMESTAMP WITH TIME ZONE for all timestamps"
  
  # Migrations
  migrations:
    rules:
      - "Always include both up and down migrations"
      - "Test migrations on development before production"
      - "Back up data before running migrations"
      - "Use descriptive migration names"

# Server-Side Implementation
server:
  components:
    directives: ["'use server'", "authentication check", "try-catch blocks", "error logging"]
  
  actions:
    location: "utils/actions"
    structure:
      - "'use server' directive required"
      - "Separate file per resource type"
      - "Named exports for each action"
      - "User ID resolution before operations"
    naming:
      prefix: ["fetch", "create", "update", "delete"]
      format: "prefixResourceName (e.g., fetchUsers, createPost)"
  
  api:
    required_steps:
      - "Authentication check"
      - "Database user ID lookup"
      - "Data validation"
      - "Database operation"
      - "Error handling"
      - "Response formatting"
    response_format:
      success: "NextResponse.json({ data })"
      error: "new NextResponse('message', { status: code })"

# Type System
types:
  organization:
    base_location: "utils/types"
    structure:
      - "Domain-specific files in utils/types/"
      - "Root types.ts only re-exports and common utilities"
    naming:
      schemas: "camelCase with Schema suffix (e.g., userSchema)"
      types: "PascalCase (e.g., User, SessionWithRelations)"
      files: "domain name in singular form (e.g., user.ts, session.ts)"
    validation:
      - "Use Zod for all schema definitions"
      - "Use Prisma native enums where available"
      - "Export both schemas and inferred types"
    required_patterns:
      base_schemas:
        - "createSchema for creation"
        - "updateSchema for updates"
        - "base schema for full model"
      common_fields:
        - "id: z.number() for database IDs"
        - "createdAt/updatedAt as dates"
        - "Proper nullability with .nullable()"
    imports:
      - "Import Prisma types from @prisma/client"
      - "Import Zod from zod"
      - "No cross-importing between domain files"

# Error Handling
errors:
  logging:
    format: "console.error('[CONTEXT_ERROR]', error)"
    contexts: ["API", "AUTH", "DB", "PAYMENT", "WEBHOOK", "TYPE", "VALIDATION"]
  return_format: "{ data: T | null, error: Error | null }"

# Integrations
integrations:
  stripe:
    rules: ["Secret key server-side only", "Webhook handlers", "Supabase storage", "Error handling"]
  
  calendly:
    structure:
      lib: ["lib/calendly-api.ts", "lib/calendly.ts"]
      features: ["Server-side API calls", "Client widget", "Webhook handling"]
      storage: ["Supabase event storage", "User profile linking"]
  
  zoom:
    structure:
      lib: ["lib/zoom-api.ts", "app/api/zoom/auth/"]
      features: ["Server-side creation", "JWT auth", "Webhook processing"]
      security: ["Server-side credentials", "OAuth flow", "Token validation"]

# Meeting Scheduling
scheduling:
  flow: ["Calendly event", "Zoom meeting", "Database record", "Notification"]
  required_fields:
    event: ["start_time", "end_time", "attendees", "meeting_link"]
    storage: ["event_id", "meeting_id", "user_id", "status"]
  error_handling: ["Double booking", "API failures", "Timezone issues", "Creation failures"]

# Documentation
documentation:
  required_comments: ["Complex types", "Schema relationships", "Validation rules"]
  jsdoc_format: |
    /**
     * @description Type description
     * @property {type} name - Property description
     */ 