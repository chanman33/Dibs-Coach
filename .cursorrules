# Project Implementation Rules
version: 1.0

# Core Configuration
core:
  directories:
    lib: "Core API configurations & base implementations"
    app/api: "API routes & endpoints"
    utils: "Helpers, types, & server actions"
    components: "UI components & client-side logic"
  
  env_vars:
    server_side: "direct process.env access"
    client_side: "NEXT_PUBLIC_ prefix required"
    validation: "type-safe with runtime checks"
  
  security:
    forbidden: ["Exposed API keys", "Unvalidated inputs", "Missing CORS headers"]
    required: ["Rate limiting", "Security event logging", "Input sanitization", "Authentication checks"]

# Authentication & Database
auth:
  clerk:
    import: "import { auth } from '@clerk/nextjs/server'"
    core_utilities:
      location: "utils/auth.ts"
      functions:
        - "createAuthClient: reusable Supabase client for auth"
        - "ensureUserExists: handle user creation/updates"
        - "getUserDbIdAndRole: fetch user role info"
        - "updateUser: handle profile updates"
    rules:
      - "await auth() required"
      - "Server-side auth checks"
      - "Webhook event handling"
      - "Supabase user sync via ensureUserExists"
      - "Protected routes in middleware"
      - "No @clerk/nextjs without server"
    sign_up:
      location: "app/(auth)/sign-up/[[...sign-up]]/page.tsx"
      flow:
        - "Clerk SignUp component for auth"
        - "Redirect to onboarding"
        - "Server-side user creation via after-signup API"
    after_signup:
      location: "app/api/auth/after-signup/route.ts"
      flow:
        - "Verify auth status"
        - "Call ensureUserExists"
        - "Handle errors appropriately"

database:
  # General Rules
  supabase:
    required: true
    usage: "All data operations must use Supabase client"
    client_init:
      import: "import { createServerClient } from '@supabase/ssr'"
      cookies: "await cookies() from next/headers"
      config:
        url: "process.env.SUPABASE_URL"
        key: "process.env.SUPABASE_SERVICE_KEY"
      implementation: "Use createAuthClient from utils/auth.ts"
  
  prisma:
    allowed_for: "schema management and migrations only"
    forbidden: "direct database operations"
    seeding:
      location: "prisma/seed.js"
      format: "CommonJS format with require() statements"
      dependencies: ["@supabase/supabase-js", "dotenv"]
      required_fields: ["updatedAt", "JSON.stringify for arrays/objects"]
      error_handling: "console.error('Seed error:', error)"
  
  # Naming & Structure
  conventions:
    tables:
      format: "PascalCase"
      examples:
        - "User not users"
        - "CoachApplication not coach_applications"
        - "RealtorProfile not realtor_profile"
        - "CalendlyIntegration"
      rules:
        - "Must match exact case in queries"
        - "Singular form, not plural"
        - "Compound names should be clear and descriptive"
    
    columns:
      primary_key: 
        format: "id"
        type: "BIGINT NOT NULL"
      foreign_keys:
        format: "camelCase with DbId suffix"
        type: "BIGINT NOT NULL"
        examples:
          - "userDbId"
          - "coachDbId"
          - "menteeDbId"
        rules:
          - "Must reference database id, not Clerk id"
          - "Must include DbId suffix for clarity"
          - "Must use BIGINT type"
      auth_identifier:
        format: "userId"
        type: "TEXT NOT NULL"
        usage: "Only for Clerk auth ID storage"
        location: "Only in User table"
      regular_columns:
        format: "camelCase"
        examples:
          - "firstName"
          - "lastName"
          - "profileImageUrl"
      timestamps:
        required:
          - "createdAt: TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
          - "updatedAt: TIMESTAMP WITH TIME ZONE"
        format: "camelCase"
        operations: "Must include updatedAt: new Date().toISOString() in all insert/update operations"
    
    queries:
      supabase:
        table_reference: '.from("User") // Exact PascalCase required'
        column_reference: '.eq("userId", value) // Exact camelCase required'
        examples:
          correct:
            - '.from("User").select()'
            - '.from("RealtorProfile").eq("userDbId", id)'
          incorrect:
            - '.from("user").select()'
            - '.from("realtor_profile").eq("user_id", id)'
  
  # ID Management
  id_conventions:
    auth:
      clerk_id: "userId: TEXT (e.g., user_2r0JFaVbINR4TBRNFzcwIsyEXV0)"
      location: "Only stored in User table"
    database:
      internal_id: "ulid: String @id @db.Char(26) @default(dbgenerated('generate_ulid()'))"
      foreign_key: "entityUlid: String @db.Char(26) (references Entity.ulid)"
    usage:
      - "Use userId (string) when querying by Clerk ID in User table only"
      - "Use ulid for all database relationships"
      - "Never use Clerk IDs in foreign key relationships"
  
  # Relationships
  relationships:
    naming:
      primary_keys: "ulid String @id @db.Char(26) @default(dbgenerated('generate_ulid()'))"
      foreign_keys: "entityUlid String @db.Char(26) REFERENCES Entity(ulid)"
    constraints:
      - "All foreign keys must reference ULID fields"
      - "All foreign keys should have appropriate indexes"
      - "Use descriptive names for relationship fields"
      - "Add map parameter for duplicate constraint names"
    multiple_relations:
      - "When a table has multiple relationships to the same table, specify the exact relationship in joins"
      - "Example: User!CoachApplication_userUlid_fkey for applicant, User!CoachApplication_reviewedBy_fkey for reviewer"
  
  # Required Fields & Indexes
  required_fields:
    id:
      format: "String @id @db.Char(26)"
      default: "@default(dbgenerated('generate_ulid()'))"
      foreign_key: "String @db.Char(26)"
    timestamps:
      format: "TIMESTAMP WITH TIME ZONE"
      fields:
        - "createdAt DEFAULT NOW()"
        - "updatedAt"
      operations: "Must include updatedAt in all insert/update operations"
    indexes:
      - "Add @@index([foreignKeyUlid]) for all foreign keys"
      - "Add @unique where appropriate for one-to-one relationships"
  
  # Best Practices
  best_practices:
    auth:
      - "Use ensureUserExists for user management"
      - "Convert Clerk ID to ULID early in API routes"
      - "Use ULIDs for all internal operations"
      - "Keep auth logic separate from database logic"
    naming:
      - "Use descriptive suffixes: Ulid for foreign keys"
      - "Be explicit about ID types in field names"
      - "Use consistent naming across related tables"
    types:
      - "Use String @db.Char(26) for all ULIDs"
      - "Use TEXT for Clerk userId and other string identifiers"
      - "Use TIMESTAMP WITH TIME ZONE for all timestamps"
    error_handling:
      - "Use consistent error logging format"
      - "Include context in error messages"
      - "Handle edge cases appropriately"
      - "Proper error responses in API routes"
  
  # Migrations
  migrations:
    rules:
      - "Always include both up and down migrations"
      - "Test migrations on development before production"
      - "Back up data before running migrations"
      - "Use descriptive migration names"

# Server-Side Implementation
server:
  components:
    directives: ["'use server'", "authentication check", "try-catch blocks", "error logging"]
  
  actions:
    location: "utils/actions"
    structure:
      - "'use server' directive required"
      - "Separate file per resource type"
      - "Named exports for each action"
      - "User ID resolution before operations"
    naming:
      prefix: ["fetch", "create", "update", "delete"]
      format: "prefixResourceName (e.g., fetchUsers, createPost)"
  
  api:
    required_steps:
      - "Authentication check"
      - "Database user ID lookup"
      - "Data validation"
      - "Database operation"
      - "Error handling"
      - "Response formatting"
    response_format:
      success: "NextResponse.json({ data })"
      error: "new NextResponse('message', { status: code })"

# Type System
types:
  organization:
    base_location: "utils/types"
    structure:
      - "Domain-specific files in utils/types/"
      - "Root types.ts only re-exports and common utilities"
      - "Keep enums and constants in the domain file where they are primarily used"
      - "Export types from a single source of truth"
    naming:
      schemas: "camelCase with Schema suffix (e.g., userSchema)"
      types: "PascalCase (e.g., User, SessionWithRelations)"
      files: "domain name in singular form (e.g., user.ts, session.ts)"
      enums:
        format: "SCREAMING_SNAKE_CASE for values"
        examples:
          - "export const GOAL_STATUS = { IN_PROGRESS: 'IN_PROGRESS' }"
          - "export const GOAL_TYPE = { SALES_VOLUME: 'SALES_VOLUME' }"
        rules:
          - "Enum values should match their keys"
          - "Use 'as const' assertion for type safety"
          - "Export both enum and derived type"
    validation:
      - "Use Zod for all schema definitions"
      - "Remove reference to Prisma native enums"
      - "Export both schemas and inferred types"
      - "Ensure enum values match their types exactly"
      - "For Zod enums, use z.enum() with explicit values array"
      - "Define enum values as uppercase constants"
      - "Validate enum values match database constraints"
      examples:
        - |
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS',
            COMPLETED: 'COMPLETED',
            OVERDUE: 'OVERDUE'
          } as const;
          
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS))
          });
    type_safety:
      - "Avoid duplicate type definitions across files"
      - "Import types from their canonical source"
      - "Use type assertions sparingly and only when necessary"
      - "Ensure enum values and their types are synchronized"
      - "Use 'as const' with enum objects to preserve literal types"
      - "Export both enum object and TypeScript type"
      examples:
        - |
          // Correct enum definition
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS'
          } as const;
          
          export type GoalStatus = typeof GOAL_STATUS[keyof typeof GOAL_STATUS];
          
          // Correct schema usage
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS) as [string, ...string[]])
          });
    required_patterns:
      base_schemas:
        - "createSchema for creation"
        - "updateSchema for updates"
        - "base schema for full model"
      common_fields:
        - "id: z.number() for database IDs"
        - "createdAt/updatedAt as dates"
        - "Proper nullability with .nullable()"
      enums:
        - "Define constants and types in the same file"
        - "Use string literal types that match exactly"
        - "Export both const object and type"
    imports:
      - "Import Supabase types from '@supabase/supabase-js'"
      - "Import Database types from '@/types/supabase'"
      - "Import Zod from zod"
      - "No cross-importing between domain files"
      - "Import types from their original definition file"
      - "Use generated Supabase types for database operations"
      - "Keep custom type definitions aligned with Supabase schema"

    supabase_types:
      - "Use Database type for table definitions"
      - "Use Tables type for table names"
      - "Use Enums type for database enums"
      - "Use generated types for insert/update operations"
      examples:
        - "type DbTables = Database['public']['Tables']"
        - "type User = DbTables['User']['Row']"
        - "type InsertUser = DbTables['User']['Insert']"
        - "type UpdateUser = DbTables['User']['Update']"

# Error Handling
errors:
  logging:
    format: "console.error('[CONTEXT_ERROR]', error)"
    contexts: ["API", "AUTH", "DB", "PAYMENT", "WEBHOOK", "TYPE", "VALIDATION"]
  return_format: "{ data: T | null, error: Error | null }"
  client_server:
    validation_errors:
      format: |
        {
          code: 'VALIDATION_ERROR',
          message: string,
          details: z.ZodError.flatten()
        }
      handling:
        - "Always return structured error objects from server actions"
        - "Include error code, message, and details"
        - "Preserve ZodError details for form validation"
        - "Log full error on server, sanitized error on client"
      examples: |
        // Server-side
        if (error instanceof z.ZodError) {
          console.error('[VALIDATION_ERROR]', {
            error,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          return {
            data: null,
            error: {
              code: 'VALIDATION_ERROR',
              message: 'Invalid form data',
              details: error.flatten()
            }
          };
        }

        // Client-side
        try {
          const result = await submitForm(data);
          if (result.error) {
            if (result.error.code === 'VALIDATION_ERROR') {
              // Handle validation errors in the form
              setFormErrors(result.error.details);
            } else {
              // Handle other errors
              toast.error(result.error.message);
            }
          }
        } catch (error) {
          console.error('[SUBMIT_FORM_ERROR]', {
            error,
            timestamp: new Date().toISOString()
          });
          toast.error('Failed to submit form');
        }

  server_actions:
    error_handling:
      - "Use withServerAction wrapper for consistent error handling"
      - "Log full error context on server side"
      - "Return structured error responses"
      - "Include error code and message"
      - "Add timestamp to error logs"
      - "Preserve stack traces in development"
    validation:
      - "Validate all inputs with Zod schemas"
      - "Return detailed validation errors"
      - "Log validation failures with context"
      - "Include original and parsed values in logs"
    examples: |
      export const submitForm = withServerAction(
        async (data, { userUlid }) => {
          try {
            const validatedData = schema.parse(data);
            // ... rest of the action
          } catch (error) {
            console.error('[ACTION_ERROR]', {
              error,
              data,
              userUlid,
              stack: error instanceof Error ? error.stack : undefined,
              timestamp: new Date().toISOString()
            });
            return {
              data: null,
              error: {
                code: error instanceof z.ZodError ? 'VALIDATION_ERROR' : 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unexpected error occurred',
                details: error instanceof z.ZodError ? error.flatten() : undefined
              }
            };
          }
        }
      );

# Integrations
integrations:
  stripe:
    rules: ["Secret key server-side only", "Webhook handlers", "Supabase storage", "Error handling"]
  
  calendly:
    structure:
      lib: ["lib/calendly-api.ts", "lib/calendly.ts"]
      features: ["Server-side API calls", "Client widget", "Webhook handling"]
      storage: ["Supabase event storage", "User profile linking"]
  
  zoom:
    structure:
      lib: ["lib/zoom-api.ts", "app/api/zoom/auth/"]
      features: ["Server-side creation", "JWT auth", "Webhook processing"]
      security: ["Server-side credentials", "OAuth flow", "Token validation"]

# Meeting Scheduling
scheduling:
  flow: ["Calendly event", "Zoom meeting", "Database record", "Notification"]
  required_fields:
    event: ["start_time", "end_time", "attendees", "meeting_link"]
    storage: ["event_id", "meeting_id", "user_id", "status"]
  error_handling: ["Double booking", "API failures", "Timezone issues", "Creation failures"]

# Documentation
documentation:
  required_comments: ["Complex types", "Schema relationships", "Validation rules"]
  jsdoc_format: |
    /**
     * @description Type description
     * @property {type} name - Property description
     */ 