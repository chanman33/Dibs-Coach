# Project Implementation Rules
version: 1.0

# Core Configuration
core:
  directories:
    lib: "Core API configurations & base implementations"
    app/api: "API routes & endpoints"
    utils: "Helpers, types, & server actions"
    components: "UI components & client-side logic"
  
  env_vars:
    server_side: "direct process.env access"
    client_side: "NEXT_PUBLIC_ prefix required"
    validation: "type-safe with runtime checks"
  
  security:
    forbidden: ["Exposed API keys", "Unvalidated inputs", "Missing CORS headers"]
    required: ["Rate limiting", "Security event logging", "Input sanitization", "Authentication checks"]


database:
  # General Rules
  supabase:
    required: true
    usage: "All data operations must use Supabase client"
    client_init:
      import: "import { createServerClient } from '@supabase/ssr'"
      cookies: "await cookies() from next/headers"
      config:
        url: "process.env.SUPABASE_URL"
        key: "process.env.SUPABASE_SERVICE_KEY"
      implementation: "Use createAuthClient from utils/auth.ts"
  
  cal:
    required: true
    usage: "All data operations must use Cal.com client"
    client_init:
      import: "import { createCalClient } from '@/utils/cal'"
      cookies: "await cookies() from next/headers"
      config:

    Always confirm that the user has a valid Cal.com token before performing any actions.
    Always confirm Cal.com successfully completed the action before updating the database.
  
  prisma:
    allowed_for: "schema management and migrations only"
    forbidden: "direct database operations"
    seeding:
      location: "prisma/seed.js"
      format: "CommonJS format with require() statements"
      dependencies: ["@supabase/supabase-js", "dotenv"]
      required_fields: ["updatedAt", "JSON.stringify for arrays/objects"]
      error_handling: "console.error('Seed error:', error)"
  
  # Naming & Structure
  conventions:
    tables:
      format: "PascalCase"
      examples:
        - "User not users"
        - "CoachApplication not coach_applications"
        - "RealtorProfile not realtor_profile"
        - "CalIntegration"
      rules:
        - "Must match exact case in queries"
        - "Singular form, not plural"
        - "Compound names should be clear and descriptive"
    
    columns:
      primary_key: 
        format: "id"
        type: "BIGINT NOT NULL"
      foreign_keys:
        format: "camelCase with DbId suffix"
        type: "BIGINT NOT NULL"
        examples:
          - "userDbId"
          - "coachDbId"
          - "menteeDbId"
        rules:
          - "Must reference database id, not Clerk id"
          - "Must include DbId suffix for clarity"
          - "Must use BIGINT type"
      auth_identifier:
        format: "userId"
        type: "TEXT NOT NULL"
        usage: "Only for Clerk auth ID storage"
        location: "Only in User table"
      regular_columns:
        format: "camelCase"
        examples:
          - "firstName"
          - "lastName"
          - "profileImageUrl"
      timestamps:
        required:
          - "createdAt: TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
          - "updatedAt: TIMESTAMP WITH TIME ZONE"
        format: "camelCase"
        operations: "Must include updatedAt: new Date().toISOString() in all insert/update operations"
    
    queries:
      supabase:
        table_reference: '.from("User") // Exact PascalCase required'
        column_reference: '.eq("userId", value) // Exact camelCase required'
        examples:
          correct:
            - '.from("User").select()'
            - '.from("RealtorProfile").eq("userDbId", id)'
          incorrect:
            - '.from("user").select()'
            - '.from("realtor_profile").eq("user_id", id)'
  
  # ID Management
  id_conventions:
    auth:
      clerk_id: "userId: TEXT (e.g., user_2r0JFaVbINR4TBRNFzcwIsyEXV0)"
      location: "Only stored in User table"
    database:
      internal_id: "ulid: String @id @db.Char(26)"
      foreign_key: "entityUlid: String @db.Char(26) (references Entity.ulid)"
      generation: 
        location: "Client-side only"
        utility: "utils/ulid.ts"
        rules:
          - "Never use database-level ULID generation"
          - "Always generate ULIDs before database operations"
          - "Use provided ULID utility functions for all generations"
    usage:
      - "Use userId (string) when querying by Clerk ID in User table only"
      - "Use ulid for all database relationships"
      - "Never use Clerk IDs in foreign key relationships"
      - "Generate all ULIDs client-side before database operations"
  
  # Relationships
  relationships:
    naming:
      primary_keys: "ulid String @id @db.Char(26)"
      foreign_keys: "entityUlid String @db.Char(26) REFERENCES Entity(ulid)"
    constraints:
      - "All foreign keys must reference ULID fields"
      - "All foreign keys should have appropriate indexes"
      - "Use descriptive names for relationship fields"
      - "Add map parameter for duplicate constraint names"
    multiple_relations:
      - "When a table has multiple relationships to the same table, specify the exact relationship in joins"
      - "Example: User!CoachApplication_userUlid_fkey for applicant, User!CoachApplication_reviewedBy_fkey for reviewer"
  
  # Required Fields & Indexes
  required_fields:
    id:
      format: "String @id @db.Char(26)"
      generation: "Client-side ULID generation required before insert"
      foreign_key: "String @db.Char(26)"
    timestamps:
      format: "TIMESTAMP WITH TIME ZONE"
      fields:
        - "createdAt DEFAULT NOW()"
        - "updatedAt"
      operations: "Must include updatedAt in all insert/update operations"
    indexes:
      - "Add @@index([foreignKeyUlid]) for all foreign keys"
      - "Add @unique where appropriate for one-to-one relationships"
      - "ULID fields automatically indexed by create_ulid_indexes() function"
  
  # Best Practices
  best_practices:
    auth:
      - "Use ensureUserExists for user management"
      - "Convert Clerk ID to ULID early in API routes"
      - "Use ULIDs for all internal operations"
      - "Keep auth logic separate from database logic"
    naming:
      - "Use descriptive suffixes: Ulid for foreign keys"
      - "Be explicit about ID types in field names"
      - "Use consistent naming across related tables"
    types:
      - "Use String @db.Char(26) for all ULIDs"
      - "Use TEXT for Clerk userId and other string identifiers"
      - "Use TIMESTAMP WITH TIME ZONE for all timestamps"
    error_handling:
      - "Use consistent error logging format"
      - "Include context in error messages"
      - "Handle edge cases appropriately"
      - "Proper error responses in API routes"
    ulid:
      - "Always generate ULIDs using provided utility functions"
      - "Generate ULIDs immediately before database operations"
      - "Never rely on database-level ULID generation"
      - "Include error handling for ULID generation failures"
      - "Log ULID generation and usage in debug contexts"
  
  # Migrations
  migrations:
    rules:
      - "Always include both up and down migrations"
      - "Test migrations on development before production"
      - "Back up data before running migrations"
      - "Use descriptive migration names"

# Server-Side Implementation
server:
  components:
    directives: ["'use server'", "authentication check", "try-catch blocks", "error logging"]
  
  actions:
    location: "utils/actions"
    structure:
      - "'use server' directive required"
      - "Separate file per resource type"
      - "Named exports for each action"
      - "User ID resolution before operations"
    naming:
      prefix: ["fetch", "create", "update", "delete"]
      format: "prefixResourceName (e.g., fetchUsers, createPost)"
  
  api:
    required_steps:
      - "Authentication check"
      - "Database user ID lookup"
      - "Data validation"
      - "Database operation"
      - "Error handling"
      - "Response formatting"
    response_format:
      success: "NextResponse.json({ data })"
      error: "new NextResponse('message', { status: code })"

# Type System
types:
  organization:
    base_location: "utils/types"
    structure:
      - "Domain-specific files in utils/types/"
      - "Root types.ts only re-exports and common utilities"
      - "Keep enums and constants in the domain file where they are primarily used"
      - "Export types from a single source of truth"
    naming:
      schemas: "camelCase with Schema suffix (e.g., userSchema)"
      types: "PascalCase (e.g., User, SessionWithRelations)"
      files: "domain name in singular form (e.g., user.ts, session.ts)"
      enums:
        format: "SCREAMING_SNAKE_CASE for values"
        examples:
          - "export const GOAL_STATUS = { IN_PROGRESS: 'IN_PROGRESS' }"
          - "export const GOAL_TYPE = { SALES_VOLUME: 'SALES_VOLUME' }"
        rules:
          - "Enum values should match their keys"
          - "Use 'as const' assertion for type safety"
          - "Export both enum and derived type"
    validation:
      - "Use Zod for all schema definitions"
      - "Remove reference to Prisma native enums"
      - "Export both schemas and inferred types"
      - "Ensure enum values match their types exactly"
      - "For Zod enums, use z.enum() with explicit values array"
      - "Define enum values as uppercase constants"
      - "Validate enum values match database constraints"
      examples:
        - |
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS',
            COMPLETED: 'COMPLETED',
            OVERDUE: 'OVERDUE'
          } as const;
          
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS))
          });
    type_safety:
      - "Avoid duplicate type definitions across files"
      - "Import types from their canonical source"
      - "Use type assertions sparingly and only when necessary"
      - "Ensure enum values and their types are synchronized"
      - "Use 'as const' with enum objects to preserve literal types"
      - "Export both enum object and TypeScript type"
      examples:
        - |
          // Correct enum definition
          export const GOAL_STATUS = {
            IN_PROGRESS: 'IN_PROGRESS'
          } as const;
          
          export type GoalStatus = typeof GOAL_STATUS[keyof typeof GOAL_STATUS];
          
          // Correct schema usage
          export const goalSchema = z.object({
            status: z.enum(Object.values(GOAL_STATUS) as [string, ...string[]])
          });
    required_patterns:
      base_schemas:
        - "createSchema for creation"
        - "updateSchema for updates"
        - "base schema for full model"
      common_fields:
        - "id: z.number() for database IDs"
        - "createdAt/updatedAt as dates"
        - "Proper nullability with .nullable()"
      enums:
        - "Define constants and types in the same file"
        - "Use string literal types that match exactly"
        - "Export both const object and type"
    imports:
      - "Import Supabase types from '@supabase/supabase-js'"
      - "Import Database types from '@/types/supabase'"
      - "Import Zod from zod"
      - "No cross-importing between domain files"
      - "Import types from their original definition file"
      - "Use generated Supabase types for database operations"
      - "Keep custom type definitions aligned with Supabase schema"

    supabase_types:
      - "Use Database type for table definitions"
      - "Use Tables type for table names"
      - "Use Enums type for database enums"
      - "Use generated types for insert/update operations"
      examples:
        - "type DbTables = Database['public']['Tables']"
        - "type User = DbTables['User']['Row']"
        - "type InsertUser = DbTables['User']['Insert']"
        - "type UpdateUser = DbTables['User']['Update']"

# User Roles and Capabilities
roles:
  definition:
    system_roles:
      location: "utils/roles/roles.ts"
      values:
        - "SYSTEM_OWNER: highest level admin access"
        - "SYSTEM_MODERATOR: system-wide moderation"
        - "USER: standard user"
        - "COACH: coach user (deprecated, use capabilities instead)"
        - "MENTEE: mentee user (deprecated, use capabilities instead)"
    
    user_capabilities:
      location: "utils/roles/roles.ts, utils/types/user.ts"
      primary_capabilities:
        - "COACH: can act as a coach"
        - "MENTEE: can act as a mentee"
      domain_capabilities:
        description: "Domain-specific capabilities for coach profiles"
        examples:
          - "REALTOR: real estate agent specialization"
          - "INVESTOR: investment specialization"
          - "MORTGAGE: mortgage specialization"
  
  storage:
    dual_approach:
      explanation: "The system uses both boolean flags and capabilities array for core roles"
      boolean_flags:
        - "isCoach: corresponds to COACH capability"
        - "isMentee: corresponds to MENTEE capability"
      capabilities_array:
        - "String array storing all user capabilities"
        - "Must include both core and domain capabilities"
        - "Boolean flags must be kept in sync with array contents"
      sync_utility:
        location: "utils/permissions.ts"
        function: "updateUserCapabilities()"
        description: "Ensures boolean flags are updated based on array contents"
  
  best_practices:
    capability_checks:
      - "Use hasCapability() from utils/permissions.ts"
      - "Check boolean flags only for quick access path optimization"
      - "Always use utility functions rather than direct database queries"
      - "System-level admins (SYSTEM_OWNER, SYSTEM_MODERATOR) bypass capability checks"
    
    updating_capabilities:
      - "Always use addUserCapability() or removeUserCapability() from utils/permissions.ts"
      - "Never update capabilities array and boolean flags separately"
      - "Include systemRole checks for admin operations"
      - "For batch operations, use updateUserCapabilities() with complete array"
    
    constants:
      - "Use CAPABILITIES constants from utils/permissions.ts"
      - "Avoid string literals for capability names to prevent typos"
      - "Import UserCapability type for type safety"
    
  implementation:
    coach_users:
      - "Check if user is a coach with hasCapability(userId, CAPABILITIES.COACH)"
      - "Add coach capability with addUserCapability(userId, CAPABILITIES.COACH)"
      - "Remove coach capability with removeUserCapability(userId, CAPABILITIES.COACH)"
      - "For domain specialties, use addUserCapability(userId, 'REALTOR')"
    
    admin_users:
      - "Use systemRole for system-wide admin access, not capabilities"
      - "systemRole is single-value, while capabilities is an array"
      - "System admins implicitly have access to all capabilities"
      - "Update systemRole separately from capabilities"

# Error Handling
errors:
  logging:
    format: "console.error('[CONTEXT_ERROR]', error)"
    contexts: ["API", "AUTH", "DB", "PAYMENT", "WEBHOOK", "TYPE", "VALIDATION"]
  return_format: "{ data: T | null, error: Error | null }"
  client_server:
    validation_errors:
      format: |
        {
          code: 'VALIDATION_ERROR',
          message: string,
          details: z.ZodError.flatten()
        }
      handling:
        - "Always return structured error objects from server actions"
        - "Include error code, message, and details"
        - "Preserve ZodError details for form validation"
        - "Log full error on server, sanitized error on client"
      examples: |
        // Server-side
        if (error instanceof z.ZodError) {
          console.error('[VALIDATION_ERROR]', {
            error,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          return {
            data: null,
            error: {
              code: 'VALIDATION_ERROR',
              message: 'Invalid form data',
              details: error.flatten()
            }
          };
        }

        // Client-side
        try {
          const result = await submitForm(data);
          if (result.error) {
            if (result.error.code === 'VALIDATION_ERROR') {
              // Handle validation errors in the form
              setFormErrors(result.error.details);
            } else {
              // Handle other errors
              toast.error(result.error.message);
            }
          }
        } catch (error) {
          console.error('[SUBMIT_FORM_ERROR]', {
            error,
            timestamp: new Date().toISOString()
          });
          toast.error('Failed to submit form');
        }

  server_actions:
    error_handling:
      - "Use withServerAction wrapper for consistent error handling"
      - "Log full error context on server side"
      - "Return structured error responses"
      - "Include error code and message"
      - "Add timestamp to error logs"
      - "Preserve stack traces in development"
    validation:
      - "Validate all inputs with Zod schemas"
      - "Return detailed validation errors"
      - "Log validation failures with context"
      - "Include original and parsed values in logs"
    examples: |
      export const submitForm = withServerAction(
        async (data, { userUlid }) => {
          try {
            const validatedData = schema.parse(data);
            // ... rest of the action
          } catch (error) {
            console.error('[ACTION_ERROR]', {
              error,
              data,
              userUlid,
              stack: error instanceof Error ? error.stack : undefined,
              timestamp: new Date().toISOString()
            });
            return {
              data: null,
              error: {
                code: error instanceof z.ZodError ? 'VALIDATION_ERROR' : 'INTERNAL_ERROR',
                message: error instanceof Error ? error.message : 'An unexpected error occurred',
                details: error instanceof z.ZodError ? error.flatten() : undefined
              }
            };
          }
        }
      );

# Integrations
integrations:
  stripe:
    rules: ["Secret key server-side only", "Webhook handlers", "Supabase storage", "Error handling"]
  

  zoom:
    structure:
      lib: ["lib/zoom-api.ts", "app/api/zoom/auth/"]
      features: ["Server-side creation", "JWT auth", "Webhook processing"]
      security: ["Server-side credentials", "OAuth flow", "Token validation"]



# Documentation
documentation:
  required_comments: ["Complex types", "Schema relationships", "Validation rules"]
  jsdoc_format: |
    /**
     * @description Type description
     * @property {type} name - Property description
     */ 

# Database Operations
database:
  operations:
    inserts:
      required_steps:
        - "Generate ULID using utility function"
        - "Prepare insert data with generated ULID"
        - "Execute insert operation"
        - "Handle any ULID generation or insert errors"
      example: |
        const newUlid = generateUlid();
        await supabase
          .from("Table")
          .insert({
            ulid: newUlid,
            // other fields
          });
    updates:
      rules:
        - "Never update ULID fields"
        - "Use ULIDs for all where clauses"
        - "Include updatedAt timestamp"
    queries:
      rules:
        - "Use ULIDs for relationship joins"
        - "Index ULID columns for performance"
        - "Use proper ULID comparison functions"

  utilities:
    location: "utils/ulid.ts"
    required_functions:
      - "generateUlid(): Generate new ULID"
      - "isValidUlid(ulid: string): Validate ULID format"
      - "extractTimestamp(ulid: string): Extract creation time"
      - "compareUlids(a: string, b: string): Compare two ULIDs"
    error_handling:
      - "Handle generation failures gracefully"
      - "Validate ULID format before database operations"
      - "Include proper error messages and logging"
    
    usage_examples: |
      // Generate new ULID
      const ulid = generateUlid();
      
      // Insert with ULID
      if (isValidUlid(ulid)) {
        await supabase
          .from("Table")
          .insert({
            ulid,
            // other fields
          });
      }
      
      // Query by ULID
      const { data, error } = await supabase
        .from("Table")
        .select()
        .eq("ulid", targetUlid);

  indexes:
    automatic:
      - "All ULID columns automatically indexed by create_ulid_indexes()"
      - "B-tree indexes for efficient lookups and joins"
    manual:
      - "Add additional indexes for specific query patterns"
      - "Consider composite indexes for common query combinations"
    maintenance:
      - "Monitor index usage and performance"
      - "Reindex when necessary"
      - "Clean up unused indexes"

# Permission Handling
permission_management:
  # General Rules
  general:
    required: true
    centralized_service: "utils/auth/permission-service.ts"
    core_principles:
      - "All permission logic must be centralized in permissionService"
      - "Client and server checks must be synchronized"
      - "Race conditions must be prevented by proper loading state management"
      - "Permission constants must be defined in a single source of truth"
      - "Loading states must be respected before making authorization decisions"
  
  # Client-Server Synchronization
  client_server_sync:
    required: true
    description: "Client and server permission checks must be consistent"
    implementation:
      - "Permission logic must match exactly between client and server"
      - "Share constants between client and server permission checking"
      - "Server-side checks in withServerAction must match client RouteGuardProvider"
      - "Loading states must be properly managed and synchronized"
      - "Permissions must not be checked until all required data is loaded"
    constants:
      location: "utils/roles/roles.ts"
      reuse: "Import from the single source of truth"
      duplication: "Never duplicate permission constants or logic"
  
  # Loading State Management
  loading_states:
    required: true
    description: "Properly handle loading states to prevent race conditions"
    implementation:
      - "Never check permissions until relevant data is fully loaded"
      - "Show appropriate loading UI during permission verification"
      - "Use isLoading flags to track loading state of auth and org data"
      - "Handle redirects only after complete data is available"
      - "Log all permission check steps for debugging"
    error_handling:
      - "Provide clear error messages for permission failures"
      - "Log all permission check steps and decisions"
      - "Include timestamps in permission-related logs"
      - "Track the source of authorization decisions for debugging"
  
  # Permission Context
  context:
    sync: "Client and server must use the same user context structure"
    caching: "Cache permission results but invalidate when context changes"
    timestamps: "Track when permission context was last set"
    structure: |
      // Standard context structure that must be used everywhere
      {
        userId: string,           // Clerk ID
        userUlid: string,         // Database ULID
        systemRole: SystemRole,   // System-level role
        capabilities: UserCapability[], // User capabilities
        orgRole: OrgRole | undefined,  // Organization role if exists
        orgLevel: OrgLevel | undefined, // Organization level if exists
        organizationUlid: string | undefined, // Organization ID if exists
        organizationName: string | undefined   // Organization name if exists
      }
  
  # Logging
  logging:
    required: true
    format: "console.log('[CONTEXT_NAME]', { key: value })"
    contexts: ["PERMISSION_SERVICE", "ROUTE_GUARD", "SERVER_ACTION"]
    required_fields:
      - "userId: The user's ID"
      - "timestamp: Date/time of the permission check"
      - "context: What permission is being checked"
      - "result: Boolean indicating permission decision"
    debugging:
      - "Log all transitions and state changes"
      - "Include detailed context for failed checks"
      - "Track data loading completion"
      - "Log when permission cache is used/cleared"
  
  # When Implementing Guards
  implementation_rules:
    route_guard:
      - "Only make authorization decisions when ALL required data is loaded"
      - "Track redirect state to prevent multiple redirects"
      - "Use enhanced loading states with descriptive messages"
      - "Share permission constants with server-side checks"
      - "Log all authorization decisions with complete context"
    server_actions:
      - "Use the withServerAction wrapper for all server actions"
      - "Implement the same permission logic as client-side guards"
      - "Log all authorization steps and decisions"
      - "Define permission requirements explicitly"
      - "Return clear error messages for failed permission checks"
    anti_patterns:
      forbidden:
        - "Checking permissions before data is fully loaded"
        - "Different permission logic between client and server"
        - "Multiple permission checking systems"
        - "Duplicated permission constants"
        - "Missing loading states"

